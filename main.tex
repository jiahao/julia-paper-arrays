\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:
% preprint      Remove this option only once the paper is in final form.

\usepackage{amsmath}

\newcommand{\MATLAB}{\textsc{MATLAB}}

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{ARRAY '14}{June 15, 2014, Edinburgh, UK}
\copyrightyear{2014} 
%\copyrightdata{978-1-nnnn-nnnn-n/yy/mm} 
%\doi{nnnnnnn.nnnnnnn}

% Uncomment one of the following two, if you are not going for the 
% traditional copyright transfer agreement.

%\exclusivelicense                % ACM gets exclusive license to publish, 
                                  % you retain copyright

\permissiontopublish             % ACM gets nonexclusive license to publish
                                  % (paid open-access papers, 
                                  % short abstracts)

\titlebanner{Array implementations in Julia}    % These are ignored unless
\preprintfooter{Array implementations in Julia} % 'preprint' option specified.

\title{Array implementations in Julia}
\subtitle{Implementing arrays in a way that is amenable to compiler analysis}

\authorinfo{Jeff Bezanson \and Jiahao Chen \and Alan Edelman}
           {MIT Computer Science and Artificial Intelligence Laboratory}
           {\{ bezanson, jiahao, edelman \}@csail.mit.edu}

%TODO Get Dahua to sign on as coauthor
%\authorinfo{Dahua Lin}
%           {Toyota Technological Institute at Chicago}
%           {dhlin@ttic.edu}

\maketitle

\begin{abstract}
This is the text of the abstract.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

\keywords
Julia, multiple dispatch

\section{Introduction}

Arrays in today's languages (literature review stuff)

What languages are ``famous'' for arrays and how to they implement
arrays: APL, ZPL, Python/NumPy, C/Fortran. Implementation details:
row vs column major, indexing rules, etc. Implementation details constrain
how users have to deal with stuff.

Problems for static compilers for dynamics languages? Matlab in particular?

Problems with dynamic language implementations? Python?

Arrays suffer from dearth of abstraction - lots of manual implementation,
hand coded into the compiler, implementation is imposed on users.
Oftentimes the object system is disjoint from the arrays, e.g. R types,
because these subsystems were tacked onto the language at different
points in time. In NumPy, mechanisms of objects are not well used.
Detailed manual mechanisms in C code. Custom dispatch, generated code,
pretty crazy. NumPy arrays are Python objects but the mechanism of
the object system don't play a huge role in defining behavior. Objects
are lookup tables of behaviors, primarily centered around indexing
behavior. Single indexing lookup of symbols which are just integers.
Not very powerful - people think it is because it is dynamic dispatch.
We can generalize it to be tremendously more powerful.


\section{Body}

What does Julia do?

Use the object system to implement Arrays. A coherent unification
of things that were typically disjoint, e.g. in R. 

Array is a pair of (shape, linear data storage) = metadata of bounded
size O(1) + raw data O(N).

Most people do this too, maybe at most add a stride. With this basic
structure we can define behavior for multidimensional arrays. Can have
lots of nontrivial design problems.

Here we consider the indexing rules. How to compute shapes of subarrays.
How to deal with singleton dimensions is but a very special case even
though superficially the rules mention them explicitly.

Here is a good place to use Julia code to codify all the various indexing
rules that various languages have

In Julia, such indexing rules are defined in exactly one place and
can be changed later if so desired.

\subsection{The need for flexibility in array indexing rules}

In practice we may all have to reach a consensus on what rules to
use, but it should not be enforced upon uses by pure technical implementation
convenience. The point is that in Julia, these are not enforced a
priori. Sometimes the distinctions between the various indexing rules
are semantically meaningful and that's when this flexibility becomes
particularly valuable. For example Tim Holy's image 4-arrays. Quantum
mechanics when you average out multiple indistinguishable particles.
$n$-point correlations functions where which $k$ indices you average out defines
any number of lower-point $n-k$ point correlation functions.

Other semantic issues: embeddings of vectors as matrix columns? Matrix version
of circle-ellipse problem, analogous to real-complex embedding. Transposition?

\subsection{\MATLAB's indexing rules}

In \MATLAB, all arrays must have at least two dimensions: row vectors, column vectors and scalars are treated as isomorphic to matrices with dimensions $1\times N$, $N\times1$ and $1\times1$ respectively. This reflects \MATLAB's original design principle as a ``\textbf{matrix} laboratory".

Not having pure scalars can be mathematically troublesome. For example, the product $A_{m\times n} \times B_{1\times 1} \times C_{n\times p}$ is invalid under the ordinary rules of matrix multiplication for $n\ne1$; however, \MATLAB{} would allow the evaluation of this product by interpreting $B$ as a scalar which commutes with $A$ and $C$, allowing this product to be evaluated as the product of the scalar $B_{11}$ and the matrix product $A_{m\times n} \times C_{n\times p}$.

%TODO Find examples where this kind of interpretation breaks commutativity or associativity. Matrices of matrices or matrices of quaternions?

Also, all arrays are treated as if they have an infinite number of trailing singleton dimensions. This reflects a later design decision in \MATLAB{} to support multilinear algebra \cite{matlabman:ma},  albeit in a manner that does not quite mesh with the world of ordinary linear algebra. This unfortunately clashes with the \textit{linear indexing} rule in \MATLAB{} that indexing a multidimensional array with a single index automatically triggers a reshape. For example, for $A_{3\times4}$, there is an ambiguity as to whether \texttt{A[5]} means \texttt{B=A[:];B[5]} or \texttt{A[5,1,1,\dots]}, and this ambiguity has to be resolved with an arbitrary design decision.

\MATLAB{} also allows indexing with matrices, but they are treated as if they were flattened for indexing purposes, i.e.

\texttt{A(M1, M2, \dots) = A(M1(:), M2(:)), \dots}

There is also something very funky with \MATLAB's cell arrays. You have to index into them using \texttt{A\{...\}} instead of the usual \texttt{A(...)}.

%TODO Find an example for which this causes problems?

\section{Array views (Dahua's stuff)}

Also interesting are array views. In certain cases of subarray slicing,
it is possible to keep the data in place and return just a view (pointer)
to the data instead of creating a new copy in memory. In this case
the same infrastructure that applies to full arrays automatically
works for subarrays. Views are just another thing that implement the
array protocol: (length, size, getindex). Is there a point here about
code reuse? Maybe but Jeff thinks it's not crucial.


\section{Extensions of the idea}

If we redefine Array to be (shape, stride pattern and linear data
store), this would be sufficient to extend to row major vs column
major. We would have a language that is majorization-agnostic, which
defies the traditional classification.

Data locality is another interesting issue. This can be part of the definition
of Arrays.

Locality and majorization order are two facets of the more general issue - where are the data located? Data locality is an open problem. Maybe we need multipl linear data stores. Maybe we need complicated locality maps to be part of the associated metadata. But the point is that with a flexible definition in the Base library, not hard-coded into the compiler, these are design decisions that can be revisted and modified if necessary.

Another interesting possibility is the treatment of symmetric and antisymmetric
tensors, since the ability to define custom striding rules would allow for
representations of such quantities that eliminate the redundant storage of
symmetry-equivalent components. (This becomes very important in higher
dimensions $d$ since multiplicity of redundant storage grows as O($d!$).

%\appendix
%\section{Appendix Title}
%
%This is the text of the appendix, if you need one.

\acks

The authors gratefully acknowledge the enthusiatic participation of the Julia developer community for many stimulating discussions on the topic of array implementations in the Julia language.

% We recommend abbrvnat bibliography style.

\bibliography{refs}{}
\bibliographystyle{abbrvnat}

% The bibliography should be embedded for final submission.

%\begin{thebibliography}{}
%\softraggedright

%\bibitem[Smith et~al.(2009)Smith, Jones]{smith02}
%P. Q. Smith, and X. Y. Jones. ...reference text...

%\end{thebibliography}

\end{document}
